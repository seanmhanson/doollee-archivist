import { firefox } from "playwright";

/**
 * Rate Limiting Script generated by Github Copilot / Claude Sonnet 4
 * with minor adjustments.
 */

type RequestMetrics = {
  url: string;
  status: number;
  responseTime: number;
  delay: number;
  timestamp: Date;
};

type DelayGroup = {
  delay: number;
  avgTime: number;
  successRate: number;
  count: number;
};

// Use same Firefox configuration as WebScraper
const testConfig = {
  headless: true,
  slowMo: 50,
  firefoxUserPrefs: {
    "security.tls.ignore_certificate_errors": true,
    "security.insecure_connection_text.enabled": false,
  },
  contextOptions: {
    ignoreHTTPSErrors: true,
    bypassCSP: true,
    acceptDownloads: false,
  },
  httpHeaders: {
    "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)",
  },
  viewport: { width: 1280, height: 800 },
  testUrls: [
    "https://doollee.com/PlaywrightsA/adams-lee.php",
    "https://doollee.com/PlaywrightsB/baker-annie.php",
    "https://doollee.com/PlaywrightsC/churchill-caryl.php",
    "https://doollee.com/PlaywrightsD/duffy-maureen.php",
    "https://doollee.com/PlaywrightsE/edgar-david.php",
    "https://doollee.com/PlaywrightsF/frayn-michael.php",
    "https://doollee.com/PlaywrightsG/greenberg-richard.php",
    "https://doollee.com/PlaywrightsH/hare-david.php",
  ],
  delays: [3000, 2000, 1500, 1000, 750, 500],
};

async function testRateLimit() {
  console.log("üîç Testing rate limits for doollee.com...\n");
  console.log("ü¶ä Launching Firefox with SSL error handling...");

  const {
    headless,
    testUrls,
    delays,
    firefoxUserPrefs,
    contextOptions,
    httpHeaders,
    viewport,
    slowMo,
  } = testConfig;
  const browser = await firefox.launch({ headless, slowMo, firefoxUserPrefs });

  const context = await browser.newContext(contextOptions);
  const page = await context.newPage();
  await page.setExtraHTTPHeaders(httpHeaders);
  await page.setViewportSize(viewport);

  const metrics: RequestMetrics[] = [];

  for (const delay of delays) {
    console.log(`\nüìä Testing ${delay}ms delay between requests...`);
    console.log("‚îÄ".repeat(60));

    let successCount = 0;
    let shouldBreak = false;

    for (let i = 0; i < testUrls.length && !shouldBreak; i++) {
      const url = testUrls[i];
      const start = Date.now();

      try {
        const response = await page.goto(url, {
          waitUntil: "domcontentloaded",
          timeout: 60000,
        });

        const responseTime = Date.now() - start;
        const status = response?.status() ?? 0;

        const metric: RequestMetrics = {
          url,
          status,
          responseTime,
          delay,
          timestamp: new Date(),
        };

        metrics.push(metric);

        const statusIcon = status === 200 ? "‚úÖ" : "‚ùå";
        const timeIcon =
          responseTime > 10000 ? "üêå" : responseTime > 5000 ? "‚è≥" : "‚ö°";

        console.log(
          `${statusIcon} ${timeIcon} ${status} - ${responseTime}ms - ${url.split("/").pop()}`,
        );

        // Check for signs of rate limiting or server stress
        if (status === 429) {
          console.warn("‚õî Rate limit detected (429)");
          shouldBreak = true;
        } else if (status === 503 || status === 502) {
          console.warn("‚ö†Ô∏è  Server error - may be overloaded");
          shouldBreak = true;
        } else if (responseTime > 15000) {
          console.warn("‚ö†Ô∏è  Very slow response - server may be stressed");
          // Don't break, but note it
        } else if (status === 200) {
          successCount++;
        }

        // Wait before next request
        if (i < testUrls.length - 1) {
          await new Promise((resolve) => setTimeout(resolve, delay));
        }
      } catch (error: unknown) {
        console.error(`‚ùå Error with ${url}:`, (error as Error).message);
        shouldBreak = true;
      }
    }

    // Analyze this delay's performance
    const delayMetrics = metrics.filter(
      (m) => m.delay === delay && m.status === 200,
    );
    if (delayMetrics.length > 0) {
      const average =
        delayMetrics.reduce((sum, m) => sum + m.responseTime, 0) /
        delayMetrics.length;
      const max = Math.max(...delayMetrics.map((m) => m.responseTime));
      const min = Math.min(...delayMetrics.map((m) => m.responseTime));
      const median = delayMetrics.sort(
        (a, b) => a.responseTime - b.responseTime,
      )[Math.floor(delayMetrics.length / 2)].responseTime;
      const variance =
        delayMetrics.reduce(
          (sum, m) => sum + Math.pow(m.responseTime - average, 2),
          0,
        ) / delayMetrics.length;
      const stdDev = Math.sqrt(variance);

      console.log("üìà Statistics for this delay:");
      console.table({
        count: successCount,
        average,
        max,
        min,
        median,
        variance,
        stdDev,
      });

      if (average > 8000) {
        console.warn("‚ö†Ô∏è  High response times - consider longer delays");
      }
    }

    if (shouldBreak) {
      console.log("üõë Stopping tests due to errors or rate limiting\n");
      break;
    }

    // Brief pause between delay tests
    console.log("‚è∏Ô∏è  Pausing 10s before next delay test...");
    await new Promise((resolve) => setTimeout(resolve, 10000));
  }

  await browser.close();

  // Final analysis
  console.log("\nüìã FINAL ANALYSIS");
  console.log("‚ïê".repeat(50));

  const successfulMetrics = metrics.filter((m) => m.status === 200);

  if (successfulMetrics.length === 0) {
    console.log("‚ùå No successful requests - site may be down or blocking");
    return;
  }

  // Group by delay and analyze
  const delayGroups = delays
    .map((delay) => {
      const delayMetrics = successfulMetrics.filter((m) => m.delay === delay);
      if (delayMetrics.length === 0) return null;

      const avgTime =
        delayMetrics.reduce((sum, m) => sum + m.responseTime, 0) /
        delayMetrics.length;
      const successRate = (delayMetrics.length / testUrls.length) * 100;

      return {
        delay,
        avgTime: Math.round(avgTime),
        successRate: Math.round(successRate),
        count: delayMetrics.length,
      };
    })
    .filter((group) => group !== null);

  console.log("\nDelay\t\tAvg Time\tSuccess Rate\tRequests");
  console.log("‚îÄ".repeat(50));

  delayGroups.forEach((group: DelayGroup) => {
    const timeIcon =
      group.avgTime > 5000 ? "üêå" : group.avgTime > 2000 ? "‚è≥" : "‚ö°";
    const successIcon =
      group.successRate === 100 ? "‚úÖ" : group.successRate > 75 ? "‚ö†Ô∏è" : "‚ùå";
    console.log(
      `${group.delay}ms\t\t${timeIcon} ${group.avgTime}ms\t\t${successIcon} ${group.successRate}%\t\t${group.count}/${testUrls.length}`,
    );
  });

  // Recommendations
  console.log("\nüí° RECOMMENDATIONS:");
  const bestDelay = delayGroups
    .filter((g) => g.successRate === 100)
    .sort((a, b) => a.avgTime - b.avgTime)[0];

  if (bestDelay) {
    console.log(
      `‚úÖ Recommended delay: ${bestDelay.delay}ms (100% success, ${bestDelay.avgTime}ms avg)`,
    );
    console.log(
      `‚ö° For 55,000 pages: ~${Math.round((55000 * bestDelay.delay) / 1000 / 60 / 60)} hours total`,
    );
  } else {
    console.log(
      "‚ö†Ô∏è  All delays showed issues - use 3000ms+ and monitor carefully",
    );
  }

  console.log(
    "\nüèõÔ∏è  Remember: This is cultural preservation - be respectful to the server!",
  );
}

// Run the test
testRateLimit().catch(console.error);
